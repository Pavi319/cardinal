<psk-page title="What is swarm communication?">

  <psk-tok></psk-tok>

  <psk-chapter title="Procese si fenomene intilnite in programare">
    <p>In definitia de zi cu zi, un process este inteles ca o serie de evenimente si pasi inruditi (au ceva in comun) cu un input si output cunoscut. Ordinea in care se intimpla aceste evenimente sau pasi este de obicei bine definita.
    </p>
    <p>Tot in definitia de zi cu zi, un fenomen (phenomenon) este un nume dat situatiilor in care relatia de cauzalitate dintre evenimentele observate nu este bine inteleasa sau chiar nu poate fi observata.  In esenta un fenomen este ceva ce nu este inteles in detaliu sau rezultatul unui proces cu stari interne neobservabile (greu observabile sau nu ne pasa suficient ca sa le observam). Ca atare, orice fenomen tinde sa fie un concept destul de vag. O cautare pe internet sau in literatura ne lasa cu definitii si impresii contradictorii dar in acceptiunea cea mai intilnita in stiinta un fenomen este de fapt un proces sau macar se incearca definirea fenomenului sub forma cit mai riguroasa a unui proces.
    </p>
    <p>Putem considera fara mari rezerve ca activitatea de programare este activitatea de a transcrie in cod inteligibil de un computer diverse aspecte ale unor procese sau a unor fenomene privite ca procese. Aceasta modelare de procese implica dezvoltarea unor artefacte de programare ce sunt descrise sintatic in cod dar care au si o semantica si pragmatica ce exista in mintea programatorului si in calculator. Ca exemple de artefacte de programare (concepte fundamentale) pot fi enumerate: definitiile de functii, descrierea de clase, servicii, apelarea  functiilor, instantierea obiectelor, apelarea si compunerea  serviciilor
    </p>

    <psk-img src="/assets/images/swarmComm/paradigms.png" title="Programming paradigms"></psk-img>

    <p>Echipa noastra a fost preocupata de a studia mecanismele de programare sub lupa caracterului lor de procese  si de a le rafina in vederea obtinerii unei unitati conceptuale, obtinerea unei composabilitati bune a unor concepte artificial greu de compus sau obtinerea altor avantaje progmatice.</p>
    <p>In acest sens, principalul rezultat obtinut este conceptul “comunicarii de tip swarm”. Este bine cunoscut ca la baza programarii orientate obiect a stat comunicarea de mesaje din modelul actorilor.  Comunicarea de tip swarm poate fi inteleasa ca o incercare de a schimba paradigma centrala a programarii spre procese explicite. Din perspectiva noastra obiecte ce comunica one to one din OOP, functii in programarea logica, predicatele din programarea logica sunt exemple de procese si in multe situatii merita tratate si gandite in acest fel.   Programarea este un proces de modelare a unor “concepte” ce vor sa reflecte mai mult sau mai putin fidel relatii, procese si fenomene ce se intimpla in afara calculatorului.  In tabelul urmator identificam ca fiind importanta categorisirea proceselor ce apar in programare din privinta duratei de viata a proceselor.</p>

  <psk-table title= "Tipuri de procese intilnite de programatori" dimensions="20|30|50" header="true" >
    <b>Fenome</b> |    <b>Tip de proces</b> |  <b>De ce este un proces </b>
    Instanta unei clase (Obiect) |     Short living process |    Un obiect nu este static, toate modificarile care au loc in timp ne forteaza sa privim obiectele ca procese
    Un apel de functie sau de API |     Short living process |     Chiar si functiile fara side effects (pure functions) pentru a fi executate de calculatoare schimba starea memoriei in timp.  Ca atare nu pot fi privite decit ca fiind in procese cu viata scurta.
    Controlul operatiilor asincone|    Short living process |     In programarea cu functii asincrone intalnite in multe limbaje si platforme, o metoda eleganta de programare este gruparea unui set inrudit de operatii asincrone intr-un singur artefact (obiect, chain de promises etc). De obicei aceste operatii asincrone schimba starea unui obiect (sau a mai multor obiecte). Prin gruparea acestor obiecte intr-un singur concept putem vedea cum un task ce necesita executia unuia sau mai multor operatii asincrone poate fi inteles ca un proces.
    Compunerea de servicii prin coreografii |     Integration short living processes|     Compunerea de servicii in mod centralizat sau decentralizat poate fi inteles ca un proces format din toate evenimentele care au loc in diferitele locatii unde serviciile sunt realizate.
    Business process |    Long living processes |    Un process de busines este evident un proces ce se desfasoara  in timp si este reflectat de schimbari de stare in baze de date.  Prin  unificarea locurile din baza de date care sufera in timp schimbari, putem vedea esenta acestui proces.
    Smart contracts |     Long living processes |    Un contract smart este evident un proces long living ce foloseste blockchain-ul pe post de baza de date.

  </psk-table>
  </psk-chapter>


  <psk-chapter title="Summary: Technology neutral presentation of Swarm Communication">
    <p>
      Swarm communication is an concept introduced in 2013 in an article with title "Swarm Communication - a Messaging Pattern proposal for Dynamic Scalability in Cloud."[1]
      and extend and discussed in other articles regarding privacy and executable choreographies[2][3].
      The first implementations of the concept exists in two open source projects SwarmESB[4] and PrivateSky[5]
    </p>
    <p>
      The swarm communication concept was introduced in the context of software integration, in particular a choreographic enabled architecture applicable to the development
      of federated ESBs (Enterprise Service Bus)[6] in OPERANDO H2020 research project. In the swarm model, the vision of orchestration and choreography matches those presented
      in scientific literature[7] :  "Orchestration is always the control from the perspective of a party. This differs from choreography, which is more collaborative and allows
      each party involved to describe its role in the interaction. With executable choreographies implemented with swarm communication, it is possible to achieve both maintaining
      decentralization and the ability to conduct orchestration.
    </p>
    <ul>At an abstract level, understanding the execution model of swarms (both PrivateSky and SwarmESB) revolves around the following elements:
    <li>
      <b>Swarm descriptions</b>: Similar to the description of an object-oriented class, the description of a swarm comprises the descriptions of all <b>phases</b>, actions and variables of swarm.
      Swarm <b>variables</b> are the way to represent the state of the swarm from the point of view of execution. The phases of the execution have a double role: they contain the code of actions
      that have the role of status, but also hold in the mental model of the programmer the name of the important state through which the process passes.
      The phases are represented in the code by functions and are physically found in the description of a swarm;
    </li>
    <li>
      <b>Swarm instances</b>: From the perspective of the object-oriented programming, the instances of a swarm are just objects. But, an instance of a swarm is made up of a lot of cloned
      objects in the first instance that give identity to the entire collective instance. Basically, in a way, a swarm has two types of instances: as a local object immediately accessible
      and as a lot of objects (clones of the original object). Both perspectives are correct, but understanding and proper use require a slightly more difficult conceptualization.
      Most of the time the programmer thinks locally (which code should write for a certain phase) and then an instance is a single object.
      When designing the swarm, it must design the phases and locations globally. In fact, the concept of executable choreography is just a global perspective on the process of composing
      services or functionality. Global (at choreography level), the programmer must think about the instance of a swarm as a lot of objects and not as a single object that exists in the
      same memory space. In global mode, according to the swarm metaphor in nature, instances be little intelligent beings who only together, in greater numbers, manage to perform useful
      and complex behaviours. We are talking globally of a "collective" instancing of Swarm, as opposed to local instantiating that is individual. The instances can be seen, in the light of
      the metaphor of swarms in nature, like swarms of bees (a collective existence) consisting of individuals who visit physical locations to perform the necessary tasks at the swarm level;
    </li>
    <li>The <b>swarm</b> primitive: signals that a swarm instance will clone itself and send the new clone to another place (another location) to perform certain calculations and remote actions;
    </li>
    <li> <b>Locations</b> - The locations are primitive elements of the model of execution and give the destination for the swarm instances (bees belonging to a swarm in the metaphorical perspective).
      For obvious reasons, these will also be referred to using the term of security contexts.
    </li>
    </ul>

    <p>The PrivateSky implementation of the Swarm communication model provides a useful abstraction for programming several types of processes, with the ability to express both short-term
      and long-term processes in a form of description of a Swarm type. The basic intuition of swarms comes from the idea that these processes of creating short-term objects, cloning them
      on the network, saving them for subsequent revival, can be perceived as a single unitary entity (a process or phenomenon) that is quite similar to a swarm made by simple beings (creatures
      without great intelligence) that manifest a convergent behavior and, at certain stages, complex, when they work together (although their calculations are surprisingly simple
      evaluated at individual level).
    </p>
    <p>The descriptions of swarms are also designed to discipline programmers, encouraging them to write their code as state automatons as soon as possible in the development process.
      In the typical object-oriented languages, a programmer never creates a fully formed object with all the behaviour it will ever need, but rather it will build it over time by adding things.
      A programmer will not be aware of the "states" that a candidate class might have to be described as a state machine (automaton). So, from the outset, a programmer can consider that he has
      a sufficiently complex problem to require modelling a state automaton. Later - when the object becomes sufficiently complex - it will not do it anyway because it is too late and there is
      a need to invest serious efforts to replace the implementation with a state-of-the-day machine with equivalent functionality.
      This can be considered one of the reasons why very little industry code uses an abstraction that is easy to use, useful and, in fact, known to all since schools, such as deterministic
      finite automatons and other automata with explicit states.
    </p>
    <p>The experience with swarm programming has shown that most state machines required in daily development will be simple (have few states), and the code is even easier to write than by
      running a custom solution that hides the explicit states.
    </p>
    <p>The JavaScript was used to implement the "swarm communication" concept in SwarmESB and PrivateSky and an important source of complexity is coming from asynchronous code. As an experiment for
      control the asynchronous code a special type of swarm called "callfIow" is used. Callflows are instances of "swarm communication" that do not use the"swarm primitive". PrivateSky unified under
      the same syntax and the concept of swarm communication three types of programming artefacts: callflows, executable choreographies and smart contracts (called choreographic smart contracts).
    </p>
    <p>While callflows instances are quite similar to objects (class instances), the executable choreographies and smart contracts attract attention that a set of objects (instances) that have a
      common origin and identity but that are created in different execution spaces (security contexts or a distributed environment in general) are part of the same "thing" that swarm communication
      calls "swarms". An interesting observation when comparing objects and swarms is the fact that swarms are emphasising the process, phenomena and not "fixed things" as in objects.
      The concept of "swarm communication" is not mainstream but it has the potential to bring a new breath for object-oriented programming in the competition with functional programming.
      At a philosophical level, it is to be noted that reality is rather composed of dynamic processes that take into account the location (or locality of things) and not of things (objects in
      object-oriented programming) or mathematical relations (side effects free functions in functional programming).
    </p>

  </psk-chapter>

  <psk-chapter title="Bibliography">

    <ol>
      <li>
        Alboaie, Lenuta; Alboaie, Sinica; Panu, Andrei (2013-11). "Swarm Communication - A Messaging Pattern Proposal for Dynamic Scalability in Cloud". 2013 IEEE 10th International Conference on High Performance Computing and Communications & 2013 IEEE International Conference on Embedded and Ubiquitous Computing. IEEE. doi:10.1109/hpcc.and.euc.2013.277. ISBN 9780769550886.
      </li>

      <li>
        Lenuta Alboaie, Sînică Alboaie, and Tudor Barbu. Extending swarm communication to unify choreography and long-lived processes. At 23rd International Conference on Information Systems Development (ISD2014 Croatia), 2014.
      </li>

      <li>
        Sînică Alboaie, Lenuta Alboaie, and Andrei Panu. Levels of Privacy for e-Health systems in the cloud era. At 24th International Conference on Information Systems Development. Harbin, China, August 25-27, 2015.
      </li>

      <li>
        Sînică, Alboaie (2019-10-11), A light, open source, ESB or message hub for node.js. Using the "swarm communication pattern": salboaie/SwarmESB, retrieved 2019-10-18
      </li>

      <li>
        "PrivateSky: Blockchains, Secret Smart Contracts and advanced privacy preserving integration (ESBs) using executable choreographies". GitHub. Retrieved 2019-10-18.
      </li>

      <li>
        "Executable choreographies applied in OPERANDO / CSJM v.24, n.3 (72), 2016 / Ediţii / CSJM / Publicaţii / IMI". www.math.md. Retrieved 2019-10-18.
      </li>

      <li>
        Peltz, Chris (2003-10). "Web Services Orchestration and Choreography". Computer. 36 (10): 46–52. doi:10.1109/MC.2003.1236471. ISSN 0018-9162.
      </li>
    </ol>

  </psk-chapter>

</psk-page>
