<psk-page title="Advanced topics">
  <psk-chapter title="Strategies in the execution engine of swarms. Blockchain domains in PrivateSky.">
    <p align="justify">All applications developed using PrivateSky technologies will be run in what we call <i>"blockchain domain"</i>. A blockchain domain, it is an environment for running internal DSL JavaScript code for swarms.</p>
    <p>Our research has identified 4 PrivateSky domains, as can be seen in the following figure:</p>
    <psk-img src="/pages/Development/TypesOfDomains.png" title="Types of domains"></psk-img>
    <p align="justify">These types of domains, if implemented with PrivateSky, require swarm communication in different ways of execution environments.</p>
    <p align="justify">We have several ways to run (execute) the PrivateSky domain code as shown in the following image:</p>
    <psk-img src="/pages/Development/TypesOfExecutions.png" title="Types of executions in PrivateSky"></psk-img>
    <p align="justify">In the ThreadExecution execution mode, PrivateSky provides node.js workers.</p>
    <p align="justify">In IsolateExecution execution mode, PrivateSky provides a swarm communication execution environment based on Isolates technology.</p>
    <p align="justify">For the execution of self sovereign applications, the ServiceWorkerExecution execution mode is used. As the name suggests, the PrivateSky domains represented in the form of CSB (Cloud Safe Box) are executed in service workers.</p>
    <p align="justify">CLIExecution calls ThreadExecution or IsolateExecution but is different from these because it offers a different communication strategy between domains.</p>
    <p align="justify">In PrivateSky there are possible interactions:</p>
    <ul>
    	<li>With Swarms in the same process</li>
    	<li>With Swarms between processes on the same machine</li>
    	<li>With Swarms intermediate by virtualMQ</li>
    	<li>With Swarms between service workers in browsers<li>
    </ul>
    <p align="justify">From the point of view of identities (a term that symbolizes the agent in whose name a phase of the swarm is executed but also the location where it is executed) we distinguish several cases that are presented in the following table:</p>
    <psk-table title = "Use-cases for swarms" dimensions="50|50" header="true">
    	<b>Case</b> | <b>How to identify the agents</b>
    	Swarms in the same process | Strings as identities
    	Swarms between processes on the same machine | Identities that through a name service translate into local process ids
    	Swarms intermediate by virtualMQ that come from clients | Ids of agents that translate into VirtualMQ topics
    	Swarms that broadcast or communicate with other blockchain identities | Ids of agents that translate into VirtualMQ topics
    	Swarms between service workers in browsers | Strings that through a name service are reflected in localhost url to service workers
    </psk-table>

    <p align="justify">SwarmEngine operation is regulated by the following strategies:</p>
    <ul>
    	<li>SerialisationStrategy: Serialization / deserialization of swarms;</li>
    	<li>SwarmNameService: Name service that translates identities into URLs or communication channels</li>
    	<li>SwarmComm: Mechanisms of effective communication between nodes</li>
    	<li>SecurityContext: Provides signature mechanisms and stores secrets that can be used by encrypted choreographies</li>
    </ul>

    <p align="justify">These strategies are injected into SwarmEngine. SwarmEngine is used by swarm_template to implement primitives specific to swarm-type executable choreographies.</p>
    <psk-img src="/pages/Development/SwarmEngine.png" title="Swarm Engine Architecture"></psk-img>

    <psk-table title = "Swarm Engine Architecture" dimensions="25|50|25" header="true">
    	<b>Component</b> | <b>Features</b> | <b>Caller</b>
    	SwarmEngine |                                   
    	              init(identity)
    	              stop()                     | initialisation
    	              loadBar(seed, callback)
    	SerialisationStrategy | serialise(swarmInstance):JSON | swarm_template
    							deserialise(JSON):swarmInstance
        SwarmNameService | getLocation(identity):url | SwarmComm
        				   registerLocation(identity, locationObject) | -
        SwarmCommunication | sendSwarmMessage(serialisation, toIdentity) | swarm_template
        					 broadcastMessage(serialisation, toGroup) | 
        					 enableSwarmExecution(callback) | SwarmEngine
        					 loadBar(seed, callback)
        SecurityContext | generateIdentity(callback) | 
        				  getCurrentAgentIdentity()
        				  getSecret(readList, callback)
        				  shareSecret(secret, list, callback)
        				  sign(digest, writeList, all, callback)
        				  verify(pskSignature)
        				  generateRandom(len = 32)
    </psk-table>
  </psk-chapter>

  <psk-chapter title="Annotations and aspect-oriented programming">
  	<p align="justify"><b>Aspect-oriented programming (AOP)</b> is a programming paradigm that extends modularization due to the fact that it allows the separation of deep cross-cutting relationships into orthogonal aspects of behaviors. Traditional modules encapsulate participants (actors) and contain the code necessary for them to implement system services. Aspect-oriented programming modules contain the code required to implement a single service of the system, taking into account all possible actors. In other words, the aspect-oriented modules cross-cut the usage methods. The UAIC team, together with DPO researchers, is investigating ways to apply AOP for programming swarm-type executable choreographies.</p>
  </psk-chapter>

  <psk-chapter title="Types of swarms that can benefit from annotations. Approaches.">
  	<psk-table title = "Types of swarms that can benefit from annotations. Approaches." dimensions="50|50|" header="true">
    	<b>Type</b> | <b>Aspects that can be programmed using AOP with annotations</b>
    	flow | checking data types
    	swarm (verifiable choreography) | checking data types
    	encrypted choreography | checking data types
    							 automatic encryption / decryption
    							 automatic signature / verification
        serverless choreography | checking data types
        asset | checking value data types
        		checking reference data types
        		generate GraphQL schemes
        		GraphQL code generation for queries
        		GraphQL code generation for mutations
        		indexing assets
        transaction | checking data types
        choreographic smart contract | checking data types
        							   use in assets
    </psk-table>

    <psk-table title = "Use cases of the Annotations identified" dimensions="50|50|" header="true">
    	<b>Use cases</b> | <b>Description</b>
    	value data types | Annotations can be used to type (validate and verify) the properties of swarms. Value type data types are int, number, string, data, JSON
    	embedded object dată types | The initial implementation can be based on the JSON value data type
    	reference data types | This type of data refers only to assets referenced from another asset (specific to smart contracts)
    	Integration with GraphQL | generate schema description (SDL)
    							   automatic generation of Queries
    							   automatic generation of Mutations
    	encrypted choreographies and smart contracts that use encryption | The use of security contexts can be facilitated by the use of annotations that mark the fact that the data must be encrypted, decrypted, signed or authenticated.
    	indexing assets in the blockchain | assets can have fields annotated with index annotation which signals that world state cache will index assets after that field to speed query
    </psk-table>
  </psk-chapter>

  <psk-chapter title="Syntax of Annotations">
  	<p align="justify">We will use the EBNF (Extended Backus-Naur Form) to describe the specific syntax of the new annotation mechanisms achieved through research in collaboration with the DPO.</p>

  <psk-table title = "Swarm variable syntax definition" dimensions="50|50|" header="false">
  	identifier                  |     COMMA 
   : [_|ALFA|NUMERIC]+ | : ,
   ;                   | ;
numeric                | 
   : INT               | SEMICOL
   : FLOAT             | : “:”
   ;                   | ;
                       | 
STRING                 | OPEN_PARANTHESE
   : CHARACTER+        | : “;”
   ;                   | ;
                       | 
WS                     | CLOSE_PARANTHESE
   : [ \r\n\t] -> skip |  : “;”
   ;                   | ;
                       | 
QU                     | variable
   : “                 | 	: WS identifier WS SEMICOL WS QU adnotations QU
   : ‘                 | ;
   ;
</psk-table>

<psk-table title="Annotations syntax definition" dimensions="50|50|" header="false">
	adnotations                 | params
: adnotation                    | 	:OPEN_PARANTHESE valueList
| adnotation COMMA adnotations  | CLOSE_PARANTHESE
;                               | 	;
                                | value
adnotation                      | 	: identifier
	:identifier WS params       | 	: STRING
	;                           |	: numeric
                                | valueList:
                                |	:value
                                |	:value COMMA valueList
</psk-table>

</psk-chapter>


<psk-chapter title="Mechanism for semantic annotation implementation">
	<psk-img src="/pages/Development/AnnotationEngine.png" title="Annotation Engine Mechanism"></psk-img>
	<p align="justify">The proposed implementation in the discussions with DPO is to have a generic Annotation Engine (AE) component capable of recording new types of annotations. We have currently identified several types of events that trigger an internal communication with AE:</p>
	<ul>
		<li>When uploading a scheme, it may be necessary to create certain initializations in one or more annotations registered in the AE</li>
		<li>When handling an instance of a swarm object</li>
			<ul>
				<li>Creating an instance</li>
				<li>When assigning a value to a variable in an instance</li>
			</ul>
		<li>When creating a new asset for the current blockchain replica (happens when a block is validated and the state world cache update)</li>
		<li>When serializing and deserializing a swarm</li>
	</ul>
	<p align="justify">The implementation will be routed through joint activities with DPO until a successful implementation is obtained (optimal especially from the point of view of minimizing the number of notifications sent by the AE to annotations). At this time of reporting, the optimal implementation has not yet been achieved.</p>
	<p align="justify">In the next period we will research and discover ways to better define the style of definition by annotating the interactions with security contexts for a better implementation of encrypted choreographies. Also, after the integration of the AE, we will start the effective development of the different types of annotations identified in this document.</p>
</psk-chapter>
</psk-page>
